# C 语言笔记

> 学习阮一峰老师的《[C 语言入门教程](https://wangdoc.com/clang/)》时所作的笔记。

## 基本语法

### 输出样式

```c
printf("%-5d\n", 123); // 输出为 "123  "
```

占位符前面的数字代表至少的宽度，输出时不满的宽度将在数字前以空格形式补足。

- `- （短横线）`：代表左对齐。去除为右对齐。

- `%f`：小数（包含 `float` 类型和 `double` 类型）

- `%05d`：输出时不满的宽度将以`0`补齐：`00123`

- `%.5f`：规定小数位数，不满补齐：`423.11000`

- `%+d`：输出的数值总是带有正负号：`+12` `-12`

- `%6.2f`：输出字符串最小宽度为 6，小数位数为 2。

- `%p`：内存地址的占位符，可以打印出内存地址。

- `%s`：字符串占位符。

- `%zu`：`size_t`类型。

### 作用域

块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。

嵌套时的规则：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。

### printf 输出多行

输出菱形字符。

```c
printf(
    "  *\n"
    " ***\n"
    "*****\n"
    " ***\n"
    "  *\n"
    );
```

## 运算符

### 基本运算符

1. `/` : 除法运算

   ```c
   float x = 6 / 4;
   printf("%f\n", x); // 输出 1.00000 
   float y = 6.0 / 4; // 或者写成 6 / 4.0
   printf("%f\n", y); // 输出 1.500000
   ```

   C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。

2. `%` : 求模运算（求余数）

   ```c
   6 % 4    // 2
   11 % -5  // 1
   -11 % -5 // -1
   -11 % 5  // -1
   ```

   结果的正负号由第一个运算数的正负号决定。

3. 简写

   ```c
   i += 3; // 等同于 i = i + 3
   i -= 8; // 等同于 i = i - 8
   i *= 9; // 等同于 i = i * 9
   i /= 2; // 等同于 i = i / 2
   i %= 5; // 等同于 i = i % 5
   ```

### 自增运算符，自减运算符

`++`：自增运算符

`--`：自减运算符

```c
i++; // 等同于 i = i + 1
i--; // 等同于 i = i - 1
```

`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；`var++`和`var--`则是先返回操作前`var`的值，再执行自增或自减操作。

```c
int i = 42;
int j;

j = (i++ + 10);
// i: 43
// j: 52

j = (++i + 10)
// i: 44
// j: 54
```

推荐写法：分开写

### 逻辑运算符

`!`：否运算符（改变单个表达式的真伪）。

`&&`：与运算符（两侧的表达式都为真，则为真，否则为伪）。

`||`：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。

对于逻辑运算符来说，任何非零值都表示真，零值表示伪。

```c
printf("逻辑为真时的结果：%d\n", 5 || 0);
printf("逻辑为假时的结果：%d\n", 5 && 0);
// 逻辑为真时的结果：1
// 逻辑为假时的结果：0
```

### 运算优先级

下面是部分运算符的优先级顺序（按照优先级从高到低排列）。

- 圆括号（`()`）
- 自增运算符（`++`），自减运算符（`--`）
- 一元运算符（`+`和`-`）
- 乘法（`*`），除法（`/`）
- 加法（`+`），减法（`-`）
- 关系运算符（`<`、`>`等）
- 赋值运算符（`=`）

以下是完整的 C 语言运算符优先级。

<table>
    <tr>
        <td>
            <p>优先级</p>
        </td>
        <td>
            <p>运算符</p>
        </td>
        <td>
            <p>名称或含义</p>
        </td>
        <td>
            <p>使用形式</p>
        </td>
        <td>
            <p>结合方向</p>
        </td>
        <td>
            <p>说明</p>
        </td>
    </tr>
    <tr>
        <td rowspan="4">
            <p>1</p>
        </td>
        <td>
            <p>[]</p>
        </td>
        <td>
            <p>数组下标</p>
        </td>
        <td>
            <p>数组名[常量表达式]</p>
        </td>
        <td rowspan="4">
            <p>左到右</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>()</p>
        </td>
        <td>
            <p>圆括号</p>
        </td>
        <td>
            <p>(表达式）/函数名(形参表)</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>.</p>
        </td>
        <td>
            <p>成员选择（对象）</p>
        </td>
        <td>
            <p>对象.成员名</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>-&gt;</p>
        </td>
        <td>
            <p>成员选择（指针）</p>
        </td>
        <td>
            <p>对象指针-&gt;成员名</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td rowspan="9">
            <p>2</p>
        </td>
        <td>
            <p>-</p>
        </td>
        <td>
            <p>负号运算符</p>
        </td>
        <td>
            <p>-表达式</p>
        </td>
        <td rowspan="9">
            <p>右到左</p>
        </td>
        <td rowspan="7">
            <p>单目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>~</p>
        </td>
        <td>
            <p>按位取反运算符</p>
        </td>
        <td>
            <p>~表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>++</p>
        </td>
        <td>
            <p>自增运算符</p>
        </td>
        <td>
            <p>++变量名/变量名++</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>--</p>
        </td>
        <td>
            <p>自减运算符</p>
        </td>
        <td>
            <p>--变量名/变量名--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>*</p>
        </td>
        <td>
            <p>取值运算符</p>
        </td>
        <td>
            <p>*指针变量</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&amp;</p>
        </td>
        <td>
            <p>取地址运算符</p>
        </td>
        <td>
            <p>&amp;变量名</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>!</p>
        </td>
        <td>
            <p>逻辑非运算符</p>
        </td>
        <td>
            <p>!表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>(类型)</p>
        </td>
        <td>
            <p>强制类型转换</p>
        </td>
        <td>
            <p>(数据类型)表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>sizeof</p>
        </td>
        <td>
            <p>长度运算符</p>
        </td>
        <td>
            <p>sizeof(表达式)</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <p>3</p>
        </td>
        <td>
            <p>/</p>
        </td>
        <td>
            <p>除</p>
        </td>
        <td>
            <p>表达式/表达式</p>
        </td>
        <td rowspan="3">
            <p>左到右</p>
        </td>
        <td rowspan="3">
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>*</p>
        </td>
        <td>
            <p>乘</p>
        </td>
        <td>
            <p>表达式*表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>%</p>
        </td>
        <td>
            <p>余数（取模）</p>
        </td>
        <td>
            <p>整型表达式%整型表达式</p>
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <p>4</p>
        </td>
        <td>
            <p>+</p>
        </td>
        <td>
            <p>加</p>
        </td>
        <td>
            <p>表达式+表达式</p>
        </td>
        <td rowspan="2">
            <p>左到右</p>
        </td>
        <td rowspan="2">
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>-</p>
        </td>
        <td>
            <p>减</p>
        </td>
        <td>
            <p>表达式-表达式</p>
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <p>5</p>
        </td>
        <td>
            <p>&lt;&lt;&nbsp;</p>
        </td>
        <td>
            <p>左移</p>
        </td>
        <td>
            <p>变量&lt;&lt;表达式</p>
        </td>
        <td rowspan="2">
            <p>左到右</p>
        </td>
        <td rowspan="2">
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&gt;&gt;&nbsp;</p>
        </td>
        <td>
            <p>右移</p>
        </td>
        <td>
            <p>变量&gt;&gt;表达式</p>
        </td>
    </tr>
    <tr>
        <td rowspan="4">
            <p>6</p>
        </td>
        <td>
            <p>&gt;&nbsp;</p>
        </td>
        <td>
            <p>大于</p>
        </td>
        <td>
            <p>表达式&gt;表达式</p>
        </td>
        <td rowspan="4">
            <p>左到右</p>
        </td>
        <td rowspan="4">
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&gt;=</p>
        </td>
        <td>
            <p>大于等于</p>
        </td>
        <td>
            <p>表达式&gt;=表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&lt;&nbsp;</p>
        </td>
        <td>
            <p>小于</p>
        </td>
        <td>
            <p>表达式&lt;表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&lt;=</p>
        </td>
        <td>
            <p>小于等于</p>
        </td>
        <td>
            <p>表达式&lt;=表达式</p>
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <p>7</p>
        </td>
        <td>
            <p>==</p>
        </td>
        <td>
            <p>等于</p>
        </td>
        <td>
            <p>表达式==表达式</p>
        </td>
        <td rowspan="2">
            <p>左到右</p>
        </td>
        <td rowspan="2">
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>！=</p>
        </td>
        <td>
            <p>不等于</p>
        </td>
        <td>
            <p>表达式!=表达式</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>8</p>
        </td>
        <td>
            <p>&amp;</p>
        </td>
        <td>
            <p>按位与</p>
        </td>
        <td>
            <p>表达式&amp;表达式</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>9</p>
        </td>
        <td>
            <p>^</p>
        </td>
        <td>
            <p>按位异或</p>
        </td>
        <td>
            <p>表达式^表达式</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>10</p>
        </td>
        <td>
            <p>|</p>
        </td>
        <td>
            <p>按位或</p>
        </td>
        <td>
            <p>表达式|表达式</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>11</p>
        </td>
        <td>
            <p>&amp;&amp;</p>
        </td>
        <td>
            <p>逻辑与</p>
        </td>
        <td>
            <p>表达式&amp;&amp;表达式</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>12</p>
        </td>
        <td>
            <p>||</p>
        </td>
        <td>
            <p>逻辑或</p>
        </td>
        <td>
            <p>表达式||表达式</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>双目运算符</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>13</p>
        </td>
        <td>
            <p>?:</p>
        </td>
        <td>
            <p>条件运算符</p>
        </td>
        <td>
            <p>表达式1?</p>
            <p>表达式2: 表达式3</p>
        </td>
        <td>
            <p>右到左</p>
        </td>
        <td>
            <p>三目运算符</p>
        </td>
    </tr>
    <tr>
        <td rowspan="11">
            <p>14</p>
        </td>
        <td>
            <p>=</p>
        </td>
        <td>
            <p>赋值运算符</p>
        </td>
        <td>
            <p>变量=表达式</p>
        </td>
        <td rowspan="11">
            <p>右到左</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>/=</p>
        </td>
        <td>
            <p>除后赋值</p>
        </td>
        <td>
            <p>变量/=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>*=</p>
        </td>
        <td>
            <p>乘后赋值</p>
        </td>
        <td>
            <p>变量*=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>%=</p>
        </td>
        <td>
            <p>取模后赋值</p>
        </td>
        <td>
            <p>变量%=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>+=</p>
        </td>
        <td>
            <p>加后赋值</p>
        </td>
        <td>
            <p>变量+=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>-=</p>
        </td>
        <td>
            <p>减后赋值</p>
        </td>
        <td>
            <p>变量-=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&lt;&lt;=</p>
        </td>
        <td>
            <p>左移后赋值</p>
        </td>
        <td>
            <p>变量&lt;&lt;=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&gt;&gt;=</p>
        </td>
        <td>
            <p>右移后赋值</p>
        </td>
        <td>
            <p>变量&gt;&gt;=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>&amp;=</p>
        </td>
        <td>
            <p>按位与后赋值</p>
        </td>
        <td>
            <p>变量&amp;=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>^=</p>
        </td>
        <td>
            <p>按位异或后赋值</p>
        </td>
        <td>
            <p>变量^=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>|=</p>
        </td>
        <td>
            <p>按位或后赋值</p>
        </td>
        <td>
            <p>变量|=表达式</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>15</p>
        </td>
        <td>
            <p>，</p>
        </td>
        <td>
            <p>逗号运算符</p>
        </td>
        <td>
            <p>表达式,表达式,…</p>
        </td>
        <td>
            <p>左到右</p>
        </td>
        <td>
            <p>--</p>
        </td>
    </tr>
</table>

## 流程控制

### 条件结构

#### if 语句

`if ( 条件 ) 语句`

对于只有一个语句的语句体，语句部分通常另起一行。

如果有多条语句，就需要把它们放在大括号里面，组成一个复合语句。

`if`语句可以带有`else`分支，指定条件不成立时，所要执行的代码。或者`else if`。

```c
if (条件) 
    语句
else 语句


if (条件) 
    语句
else if (条件)
    语句
else
    语句
```

#### switch 语句

```c
switch (需要判断的数据) {
    case 值1:
        语句
    case 值2:
        语句
    default:
        语句
}
```

根据变量不同的值，会执行不同的`case`分支，`default`表示处理以上所有`case`都不匹配的情况。

每个`case`语句体的结尾，都应该有一个`break`语句，作用是跳出整个`switch`结构，不再往下执行。如果缺少`break`，就会导致继续执行下一个`case`或`default`分支。

```c
switch (grade) {
  case 0:
  case 1:
    printf("True");
    break;
  default:
    printf("Illegal");
}
```

上面示例中，`case 0`分支没有任何语句且没有 `break`，导致`case 0`和`case 1`都会执行同样的语句体。

### 循环结构

#### while 语句

```c
while (i < n) {    // while (条件)
    i = i + 2;     //     语句
}
```

当型循环

条件为非零值（表示真），就会执行语句，反之跳出循环。

#### do...while 结构

直到型循环

#### for 语句

当型循环

```c
for (初始化表达式; 条件表达式; 迭代表达式) {
    语句;
}
```

上面代码中，`for`语句的条件部分（即圆括号里面的部分）有三个表达式。

- 初始化表达式：用于初始化循环变量，只执行一次。
- 条件表达式：只要为`true`，就会不断执行循环体。
- 迭代表达式：每轮循环结束后执行，使得循环变量发生变化。

`for`循环的三个部分都是可选的，但分号是必须的。

### 其余语句

#### break 语句

- 与`switch`语句搭配使用。

- 在循环体内部跳出循环。

- 不能跳出`if`结构。

```c
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        printf("%d, %d\n", i, j);
        break;
    }
}
/* 输出
0, 0
1, 0
2, 0 */
```

#### continue 语句

用于在循环体内部终止本轮循环，进入下一轮循环。

```c
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        printf("%d, %d\n", i, j);
        continue;
        printf("随便写点，%d, %d\n", i, i);
    }
}

/* 输出
0, 0
0, 1
0, 2
1, 0
1, 1
1, 2
2, 0
2, 1
2, 2 */
```

## 数据类型

### 字符类型

指单个字符：

```c
char x = 'B';
char x = 66;
char x = '\102'; // 八进制
char x = '\x42'; // 十六进制
```

### 整数类型

1. `signed`关键字，表示一个类型带有正负号，包含负值。默认包含。

2. `unsigned`关键字，表示该类型不带有正负号，只能表示零和正整数。

3. 整数变量声明为`unsigned`的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。

4. C 语言允许省略`int` ：

   ```c
   unsigned int a;
   unsigned a;
   
   short a;
   unsigned short a;
   
   long b;
   unsigned long b;
   
   long long c;
   unsigned long long c;
   ```

### 字面量后缀

- `f`和`F`：`float`类型。
- `l`和`L`：对于整数是`long int`类型，对于小数是 `long double`类型。
- `ll`和`LL`：`long long`类型，比如`3LL`。
- `u`和`U`：表示`unsigned int`，比如`15U`、`0377U`。

### 溢出

每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。

为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。

```c
unsigned int ui;
unsigned int sum;

// 错误
if (sum + ui > UINT_MAX) too_big();
else sum = sum + ui;

// 正确
if (ui > UINT_MAX - sum) too_big();
else sum = sum + ui;
```

实际工作中，注意结合数据类型与值，灵活编写。

### sizeof 运算符

返回某种数据类型或某个值占用的字节数量。

C 的一个类型`size_t`，被用来统一表示`sizeof`的返回值类型，为无符号整数。

`printf()`有专门的占位符`%zd`或`%zu`，用来处理`size_t`类型的值。

### 类型的自动转换

1. 浮点数赋予整数变量时，直接丢弃小数部分，不是四舍五入。

2. 整数赋值给浮点数变量时，会自动转为浮点数。

3. 字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。

4. 字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值。

5. 整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。

6. 不同的整数 / 浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如`int`转为`long`， `float`转为`double`等。

7. 宽度小于`int`的类型，在进行整数类型的运算时，运算结果会自动提升为`int`。

## 指针

### 简介

指针是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。

字符`*`表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，`char*`表示一个指向字符的指针。

指针变量是专门用来存放指针（地址）的变量，一般情况下也称作指针。指针变量只能存放内存地址。

这种写法有一个地方需要注意，如果同一行声明两个指针变量，那么需要写成下面这样。

```c
// 正确
int * foo, * bar;

// 错误
int* foo, bar;
```

### * 运算符

`*`这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的**内存地址*里面* 的*值***。

### & 运算符

`&`运算符用来取出一个变量所在的**内存地址**，也就是将变量的内存地址赋给指针变量。

`printf()`的`%p`是内存地址的占位符，可以打印出**内存地址**。

### 指针变量的初始化

声明指针变量之后，编译器会为指针变量本身 *随机* 分配一个内存空间。所以，必须先让它指向一个 *分配好的地址*，然后再进行读写，这叫做指针变量的初始化。否则，读写指针变量指向的随机地址，很可能会导致严重后果。

为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为`NULL`，表示地址为`0`的内存空间，这个地址是无法使用的，读写该地址会报错。

### 指针的运算

1. 指针与整数值的加减运算：表示指针的移动

2. 指针与指针的加法运算：非法

3. 指针与指针的减法运算：它们之间的距离，即相隔多少个数据单位。

4. 指针与指针的比较运算：比较的是各自的内存地址哪一个更大，返回值是整数`1`（true）或`0`（false）。

PS: 如果不获取值，即 p + 1，为指针的移动。如果获取值，即 *p + 1，为指向的值 +1

## 数组

### 简介

```c
int scores[100];
```

1. 一组相同类型的值，按照顺序储存在一起的数。括号里为数组的成员数量。

2. 声明数组时，必须给出数组的大小。

3. 数组的成员从`0`开始编号，代表数组元素与数组起始位置的偏移量。

4. 数组元素通过下标操作符`[]`进行引用，称为下标访问。

5. `sizeof`运算符会返回整个数组的字节长度。

### 赋值方式

声明数组时赋值

```c
int a[5] = {22, 37, 3490, 18, 95};
```

声明数组之后再赋值

```c
int a[5];
a[2] = 51;
```

 也可以只对其中某些位置赋值，包括混合使用

```c
int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
```

### 多维数组

C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。

```c
int board[10][10];
```

引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度。

```c
board[0][0] = 13;
board[9][9] = 13;
```

跟一维数组一样，多维数组每个维度的第一个成员也是从 `0` 开始编号，多维数组也可以使用大括号，一次性对所有成员赋值。

不管数组有多少维度，在内存里面都是线性存储，`a[0][0]`的后面是`a[0][1]`，`a[0][1]`的后面是`a[1][0]`，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句与上面的赋值语句是完全等同的。

### 变长数组

数组声明的时候，数组长度除了使用常量，也可以使用变量，这叫做变长数组。

变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。

```c
int n = x + y;
int arr[n];
```

也可以用于多维数组。

### 数组的地址

1. 数组是一连串连续储存的同类型值，知道起始地址（首个成员的内存地址），就能推算出其他成员的地址。

2. `&a[0]`和数组名`a`是等价的。

### 数组指针的加减法

一般内容见指针。

数组的两种访问方法：

```c
a[b] == *(a + b)
```

遍历数组：如果指针变量`p`指向数组的一个成员，那么`p++`就相当于指向下一个成员，这种方法常用来遍历数组。

### 数组的复制

由于数组名是指针名，所以直接使用（`=`）会让两个变量指向同一个数组（内存地址）。

以下是两种复制数组的方法：

1. 使用循环逐个复制数组元素。

2. 使用`memcpy()`函数（定义在头文件`string.h`），直接复制把数组所在的那一段内存。这种方法比循环快。

   ```c
   memcpy(a, b, sizeof(b));
   ```

## 字符串—— string.h 头文件

### 简介

C 语言没有单独的字符串类型，字符串被当作字符数组，即`char`类型的数组。

比如，字符串“Hello”是当作数组`{'H', 'e', 'l', 'l', 'o', '\0'}`处理的，结尾的`'\0'`是 C 语言字符数组的结束码。所以声明了 6 个成员的字符数组只能容纳 5 个字符。

可以使用`\`将字符串拆分为多行，或者形成转义字符。

### 声明

```c
// 写法一
char s[] = "Hello, world!";

// 写法二
char* s = "Hello, world!";
```

区别：

1. 指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。

   声明为指针时，字符串的字面量保存在不允许用户修改的内存的常量区；声明为数组时，会给字符数组单独分配一段内存，而这段内存是允许修改的。

2. 指针可以指向其他字符串，但数组不行。

写法一可以自动计算字符数组长度，也可以声明为大于字符串实际长度。字符数组的长度，不能小于字符串的实际长度。

### strlen()

`strlen()`函数返回字符串的字节长度，不包括末尾的空字符`\0`。它的参数是字符串变量，返回的是`size_t`类型的无符号整数。例如：

```c
const char* s = "YYJ";
char a[] = "YYJ";
printf("%zd", strlen(s)); // 3
printf("%zd", sizeof(s)); // 8
printf("%zd", sizeof(a)); // 4
```

注意，字符串长度（`strlen()`）与字符串变量长度（`sizeof()`），是两个不同的概念。前者计算字符串的实际长度，后者计算字符串数组的长度。

### strcpy()

字符串的复制，不能直接用赋值运算符。

```c
char str1[10];
char str2[10];

str1 = "abc"; // 报错
str2 = str1;  // 报错


char* s1;
char* s2;

s1 = "abc";
s2 = s1;
```

数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。

对于字符指针，赋值运算符（`=`）只是将一个指针的地址复制给另一个指针，而不是复制字符串。

C 语言提供了

```c
strcpy(char dest[], const char source[])
strcpy(char *des, const char *source)
```

函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。`strcpy()`**会连同字符串末尾的`'0'`一同复制**，可能提前结束目的字符串。

第一个参数是目的字符串数组，第二个参数是源字符串数组。注意：如果第一个参数的长度小于第二个参数，不会报错，但会溢出边界。

`strcpy()`也可以用于字符数组的赋值。

```c
char str[10];
strcpy(str, "abcd");
```

`strcpy()`的返回值是一个字符串指针（即`char*`），指向第一个参数。因为参数、返回值是指针，所以指向的是复制开始的位置。

```c
char* s1 = "beast";
char s2[40] = "Be the best that you can be.";
char* ps;

ps = strcpy(s2 + 7, s1); // 从第八个位置开始复制

puts(s2); // Be the beast
puts(ps); // beast
```

#### strncpy()

用法同上，只是多了第 3 个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。

注意：如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的**字符串结尾将没有终止符`\0`**。可以手动添加。

```c
strncpy(str1, str2, sizeof(str1) - 1);
str1[sizeof(str1) - 1] = '\0';
```

### strcat()

`strcat()`函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾，不会改变第二个字符串。

```c
char* strcat(char* s1, const char* s2);
```

`strcat()`的返回值是一个字符串指针，指向第一个参数。

#### strncat()

用法同上，增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符`\0`，就不再添加了。

为了安全，第三个参数通常会写作`sizeof(str1) - strlen(str1) - 1`。

### strcmp()

比较两个字符串。

```c
int strcmp(const char* s1, const char* s2);
```

如果两个字符串相同，返回值为`0`。如果不同，则根据字典比较第一不同的字符：如果`s1`小于`s2`，返回值小于 0；如果`s1`大于`s2`，返回值大于 0。同时大小写被视为不同的字符。

比较字符可以直接使用相等运算符（`==`）比较。

#### strncmp()

用法同上，增加了第三个参数，指定了比较的字符数。返回值同上。

### sprintf()

用于将数据写入字符串，而不是输出到显示器。

```c
int sprintf(char* s, const char* format, ...);
```

`sprintf()`的第一个参数是字符串指针变量，其余参数和`printf()`相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。

```c
char first[6] = "hello";
char last[6] = "world";
char s[40];

sprintf(s, "%s %s", first, last);

printf("%s\n", s); // hello world
```

返回值是写入变量的字符数量（不计入尾部的空字符`\0`），如果遇到错误，返回负值。

#### snprintf()

```c
int snprintf(char*s, size_t n, const char* format, ...);
```

用法同上，在第二个参数的位置，指定了写入变量的字符串不超过`n - 1`个字符，剩下一个位置写入空字符`\0`。`snprintf()`总是会自动写入字符串结尾的空字符。

`snprintf()`的返回值是写入格式字符串的字符数量（不计入尾部的空字符`\0`），且只有在非负并且小于`n`时，才能确认完整的格式字符串写入了变量。

## 内存管理——stdlib.h 头文件

### void 指针

每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法解读内存块保存的二进制数据。但是，有时不确定会有什么样的数据写入内存。

`void`指针只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。

`void`指针等同于无类型指针，可以指向任意类型的数据，也可以与其他所有类型的指针相互转化。但由于不知道`void`指针指向什么类型的值，所以不能用`*`运算符取出它指向的值。

### malloc() 函数

`malloc()`函数用于分配分配一段连续的内存块。

```c
void* malloc(size_t size)
```

它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个`void`指针，指向分配好的内存块。

常见的做法是先使用`sizeof()`函数，算出某种数据类型所需的字节长度，然后再将这个长度传给`malloc()`。

`malloc()`最常用的场合，就是为数组和自定义数据结构分配内存。如：它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。

```c
int* p = (int*) malloc(n * sizeof(int));
```

注意，`malloc()`不会对所分配的内存进行初始化，里面还保存着原来的值。

### free() 函数

`free()`用于释放`malloc()`函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。

```c
int* p = (int*) malloc(sizeof(int));

*p = 12;
free(p);
```

在函数内部分配了内存，在函数调用结束时，应当使用`free()`释放内存。

### calloc() 函数

（1）`calloc()`接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。

```c
void* calloc(size_t n, size_t size);
```

`calloc()`的返回值也是一个 void 指针。分配失败时，返回 NULL。

（2）`calloc()`会将所分配的内存全部初始化为`0`。

### realloc() 函数

`realloc()`函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。

```c
void* realloc(void* block, size_t size);
```

1. `block`：已经分配好的内存块指针。

2. `size`：该内存块的新大小。

`realloc()`可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。

### memcpy() 函数——string.h

`memcpy()`用于拷贝内存。

```c
void* memcpy(void* dest, void* source, size_t n);
```

1. `dest`：目标地址。

2. `source`：原地址。

3. `n`：需要拷贝的字节数。

`memcpy()`的返回值是第一个参数，即目标地址的指针。

`memcpy()`可以取代数组拷贝以及`strcpy()`进行字符串拷贝，而且是更好的方法。

## 结构体

### 简介

`struct`是 C 编程中一种允许用户自定义的复合数据类型，将不同类型的值组合在一起。

```c
struct tag {
    member-list
    member-list
    member-list
    ...
} variable;
```

1. `tag`是结构体类型。如果类型名只用在这一个地方，后面不再用到，可以省略。

2. `member-list`是结构体的属性，定义了结构体里包含哪些数据。

3. `variable-list`是结构变量，可以直接在此声明，也可以后续再声明，后续声明时不能忘记加上`struct`关键字。

   比如：`struct tag name;`，声明了一个`struct tag`类型的变量`name`。

在一般情况下，`tag`、`member-list`、`variable-list`这 3 部分至少要出现 2 个。

### 赋值

```c
struct fraction {
  int numerator;
  int denominator;
};
```

声明了一个自定义类型变量后，接着可以为它的不同属性赋值。

```c
struct fraction f1;
f1.numerator = 22; // 为单个属性赋值、修改

struct fraction f2 = {1, 3}; // 为多个属性赋值
```

也可以直接在定义结构体时赋值。

```c
struct fraction {
  int numerator;
  int denominator;
} f1 = {1, 3};
```

如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为`0`。且大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。

```c
struct fraction f3 = {.denominator=3, .numerator=1};
```

`struct`结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。

定义`struct`结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。

### 特殊成员

1. `struct`结构也可以作为数组成员。

   ```c
   struct fraction numbers[1000];
   numbers[0].numerator = 22;
   ```

2. 指针变量也可以指向`struct`结构。

   ```c
   struct fraction *f1;
   ```

### struct 的嵌套

结构体的成员可以是另一个`struct`结构

```c
struct species {
  char* name;
  int kinds;
};

struct fish {
  char* name;
  int age;
  struct species breed;
};
```

上面示例中，`fish`的属性`breed`是另一个`struct`结构`species`。

赋值的时候有多种写法。

```c
// 写法一
struct fish shark = {"shark", 9, {"Selachimorpha", 500}};

// 写法二
struct species myBreed = {"Selachimorpha", 500};
struct fish shark = {"shark", 9, myBreed};

// 写法三
struct fish shark = {
  .name="shark",
  .age=9,
  .breed={"Selachimorpha", 500}
};

// 写法四
struct fish shark = {
  .name="shark",
  .age=9,
  .breed.name="Selachimorpha",
  .breed.kinds=500
};
```

上面示例展示了嵌套`struct`结构的四种赋值写法。另外，引用`breed`属性的内部属性，要使用两次点运算符（shark.breed.name）。

另一个嵌套例子：

```c
struct name {
  char first[50];
  char last[50];
};

struct student {
  struct name name;
  short age;
  char sex;
} student1;

strcpy(student1.name.first, "Harry");
strcpy(student1.name.last, "Potter");

// 定义一个 name 类型，复制给 student1 的 name 属性
struct name myname = {"Harry", "Potter"};
student1.name = myname;
```

### struct 的复制

1. `struct`可以通过（`=`）复制给另一个变量，生成一个新的副本，同时系统也会分配一块新的内存空间。

2. 如果结构体内包含指针，则复制后的指针还是共享同一个地址。

3. 不同类型的`struct`无互相赋值。

4. C 语言无法比较两个自定义数据结构是否相等。

### struct 的指针

`struct`指针传入函数的写法如下：

```c
void function(struct tag *name) {
    (*name).member += 1;
} // 参数名包含结构体类型以及变量名

function(&tag); // 传入参数时传入指针
```

`struct`不像数组，导致调用函数时，涉及到函数的传值引用。如果希望，函数修改内部数据之后，会反映在函数外部，就需要将`struct`变量的指针传入函数。

`(*name).member`不能写为`*name.member`，因为点运算符（`.`）的优先级高于`*`，会将`name.menber`看作一个指针，出错。

C 语言引入了一个新的箭头运算符（`->`），可以从 struct 指针上直接获取属性，用以代替`(*name).member`，大大增强了代码的可读性。上述代码可写为：

```c
void function(struct tag *name) {
  name->member += 1;
}
```

## typedef 命令

### 简介

`typedef`命令用来为某个类型起别名。

```c
typedef type name;
```

1. `type`：类型名。

2. `name`：别名。

用法如下：

```c
// 将 unsigned long long 重命名为 ll
typedef unsigned long long ll;
```

### 方便之处

1. 为`struct`、`union`、`enum`等命令定义的复杂数据结构创建别名，从而便于引用。

   ```c
   typedef struct animal {
       // ...
   } animal;
   ```

   后续可以直接用`animal`代替`struct animal`。

2. `typedef`方便以后为变量改类型。

   ```c
   typedef float app_float;
   
   app_float f1, f2, f3;
   ```

   如果以后需要为它们改类型，只需要修改`typedef`语句即可。

   ```c
   typedef long double app_float;
   ```

3. 简化类型声明。

## Enum 类型

如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，可以定义为枚举类型。

这时，枚举内的属性的名字会自动成为整数变量，默认值从`0`开始。

注意，`Enum`内部的常量名，遵守标识符的命名规范，但是通常都使用大写。

## 预处理器

### #define

`#define`用来降指定的词替换成另一个词。第一个参数是要被替换的部分，其余参数是替换后的内容。

```c
#define HELLO "Hello, world"

// 相当于 printf("%s", "Hello, world");
printf("%s", HELLO);
```

`#define`允许多重替换，即一个宏可以包含另一个宏。

```c
#define TWO 2
#define FOUR TWO*TWO  // 2*2
```

注意，如果宏出现在字符串里面，或者是其他标识符的一部分，就会失效，并不会发生替换。

### 带参数的宏

#### 基本用法

宏的名称后面可以使用括号，指定接受一个或多个参数，进行替换。

```c
#define SQUARE(X) ((X) * (X))

// 输出 19
printf("%d\n", SQUARE(3 + 4));
```

这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号。

一般来说，带参数的宏都是一行的。也可以嵌套。

```c
#define MAX(x, y) ((x)>(y)?(x):(y))
#define COMPARE(order, a, b) ((order == 1) ? ((a) > (b)) : ((a) < (b)))
#define IS_EVEN(n) ((n)%2==0)
```

注意，操作符不能直接作为宏的替换部分。

一般来说，应该首先使用函数，它的功能更强、更容易理解。宏的优点是相对简单，本质上是字符串替换，不涉及数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。

#### `#`运算符 `##`运算符

由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上`#`。可以与其他字符串连用。

```c
#define XNAME(n) "x"#n

// 输出 x4
printf("%s\n", XNAME(4));
```

如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用`##`运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。

```c
#define MK_ID(n) i##n
int MK_ID(1), MK_ID(2), MK_ID(3);
// 替换成
int i1, i2, i3;
```

`##`运算符的一个主要用途是批量生成变量名和标识符。

#### 不定参数的宏

宏的参数还可以是不定数量的（即不确定有多少个参数），`...`表示剩余的参数。且`...`只能写于宏的最后。

```c
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
```

`__VA_ARGS__`代表多余的参数。

### #include

`#include`指令用于编译时将其他源码文件，加载进入当前文件。

```c
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件

// 形式三
#include "/usr/local/lib/foo.h"  // 所要包含的文件在其他位置，需要指定路径
```

### #if...#endif

`#if...#endif`指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。

`#if 0`这种写法常用来当作注释使用。

```c
#if 0
  const double pi = 3.1415; // 不会执行
#endif
```

`#if...#endif`之间还可以加入`#else`指令，用于指定判断条件不成立时，需要编译的语句。也可以加入`#elif`指令，用于指定多个判断条件。

```c
#if HAPPY_FACTOR == 0
  printf("I'm not happy!\n");
#elif HAPPY_FACTOR == 1
  printf("I'm just regular\n");
#else
  printf("I'm extra happy!\n");
#endif
```

`#if`的常见应用就是打开（或关闭）调试模式。（也可以是其他什么的模式。）

```c
#define DEBUG 1

#if DEBUG
printf("value of i : %d\n", i);
printf("value of j : %d\n", j);
#endif
```

### 预定义宏

- `__DATE__`：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。
- `__TIME__`：编译时间，格式为“hh:mm:ss”。
- `__FILE__`：当前文件名。
- `__LINE__`：当前行号。

## I / O 函数

### scanf()

#### 基本用法

用于读取用户的键盘输入。

```c
scanf("%d", &i);
```

注意，变量前面必须加上`&`运算符（指针变量除外），因为 `scanf()`传递的不是值，而是地址，即将变量`i`的地址指向用户输入的值。如果这里的变量是指针变量（比如字符串变量），那就不用加`&`运算符。

`scanf()`处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。
